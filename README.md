# Spring Road Map
<img src="https://github.com/minuk8932/How-to-buildup-Server-by-Spring/blob/master/img/spring-road-map.png" width=200><br>
[그림 1]스프링 로드맵
<br><br>

스프링 어떻게 공부해야 할까?<br>
<br>
**1. Java SE** : Java Standard Edition을 뜻하는 말이며, 자바의 밑바탕이 되는 것으로 스프링 프로젝트를 배우기 위해선 기본적으로 공부가 되어있어야한다.(알고리즘, 자료구조, 디자인패턴 등) 현 단계에선 최종적으로 앱 구현정도의 실력을 쌓아야한다. <br>
**2. Servlet / JSP** : 웹에 관련된 일종의 네트워크 프로그래밍으로 보면된다.(소켓이 아닌 http 환경) **Web Basic**(html, javascript, css), **Model1**(프로토타입 구현), **Model2**(MVC pattern), Web Basic를 통해 **Ajax** 사용, Action tag 중 Custon tag인 **JSTL**(JSP 문법)을 공부해 사용하는 것을 목표로한다.<br>
**3. Spring** : 사용 방식이 여러가지가 있어 개인이 직접 찾아보고 괜찮은 또는 스스로에게 알맞는 방법으로 구현 할 것. 웹/앱 모두 구현 가능. <br>
**4. SQL mapper / ORM** : SQL mapper는 좀 더 편리한 데이터베이스 사용, ORM은 데이터베이스의 역할을 대신 해주며 기존보다 더 편리하게 구현 가능하게 해주는데 진입 장벽이 매우 높은편이다. 전자의 경우 **Mybatis**(aphache ibatis에서 구글로 넘어가면서 명칭 변경), 후자의 경우엔 **Hibernate**가 있다. <br>
**5. Utility** : 생산성이 좋고 빠른 빌드 자동화 툴 **Ant**, 기능이 추가된 **Maven**(주로 사용됨), 프로젝트가(협업) 가능하도록 지원하는 **Subversion**, 단위 테스트(도중에 에러체크 또는 디버깅)가 가능한 **JUnit**이 있다. <br>
<Br>
이미지 출처 및 내용 참고 : [himan009dev 님의 Youtube 영상](https://www.youtube.com/watch?v=XJYrPMkTQtk&feature=youtu.be) (클릭하시면 해당 영상으로 이동합니다.)
<br><br>

# ORM
객체 관계 매핑(Object-relational mapping; ORM)은 데이터베이스와 객체 지향 프로그래밍 언어 간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법이다. 객체 관계 매핑 라고도 부른다. 객체 지향 언어에서 사용할 수 있는 "가상" 객체 데이터베이스를 구축하는 방법이다. 객체 관계 매핑을 가능하게 하는 상용 또는 무료 소프트웨어 패키지들이 있고, 경우에 따라서는 독자적으로 개발하기도한다. 대표적으로 **Hibernate**가 있다. (출처 : wikipedia) <br>
의의 : 코드의 반복적이고 지루한 부분을, 줄일 수 있고 SQL에 의존적인 코딩에서 벗어나, 생산적인 코딩이 가능하고, 유지보수가 편리해짐.
<br><br>

# MVC Pattern
MVC Pattern은 스프링 프레임워크에서 자체적으로 지원되고 있다. Model, View, Controller를 의미하는 것으로 소프트웨어 디자인 패턴이다. MVC에서 모델은 애플리케이션의 정보(데이터)를 나타내며, 뷰는 텍스트, 체크박스 항목 등과 같은 사용자 인터페이스 요소를 나타내고, 컨트롤러는 데이터와 비즈니스 로직 사이의 상호동작을 관리한다. <br>
*항목별로 좀 더 자세히 알아보면,* <br>
> - Model : 데이터 저장소와 연동해 사용자가 입력한 데이터나 출력 할 데이터, 그리고 트랜잭션을 컨트롤한다. DAO, Service 클래스가 모델 구성요소에 해당한다.
> - View : 모델이 처리한 데이터나 작업 결과를 가지고 화면을 띄워준다. 화면은 웹브라우저가 출력하고, 뷰 컴포넌트는 HTML/CSS/JavaScript를 사용해 웹 브라우저가 출력 할 UI를 생성한다. 일반적으로 HTML과 JSP를 통해 작성한다.
> - Controller : 클라이언트의 요청을 실제 업무를 수행하는 모델 구성요소를 호출한다. 모델 호출 시 전달하기 쉽게 데이터를 가공해주고, 모델의 수행 결과를 통해 화면을 생성하도록 뷰에 전달한다. 일반적으로 Servlet JSP를 이용해 작성한다.
- **모델**에 데이터에 대한 정의를 하고, 이를 실제로 보여주는것이 **뷰**, 그리고 데이터들을 처리하는 방식 또는 기능 등이 **컨트롤러**에 해당한다.

<img src="https://github.com/minuk8932/How-to-buildup-Server-by-Spring/blob/master/img/mvc-pattern.png" width=200>

[그림 2] MVC Pattern
<br><br>

# DAO, DTO
**DAO**: Data Access Object의 줄임말이다. Spring과 DB사이에 존재하여, DB를 사용해 데이터를 조회하거나 조작하는 기능을 담당하는 것들을 DAO라고 부른다. 도메인 로직(비즈니스 로직이나 DB와 관련없는 코드들)을 영속성 메커니즘과 분리하기 위해 사용한다. HTTP Request를 Web Application이 받게 되면 Thread를 생성하게 되는데 비즈니스 로직이 DB로부터 데이터를 얻어오기 위해 매번 Driver를 로드하고 Connection 객체를 생성하게 되면 엄청 많은 커넥션이 일어나므로 DAO를 하나 만들어 DB 전용 객체로만 사용해 성능을 높이기 위함이다. 이는 'Connection pool'의 개념에서 나왔다.
**DTO**: Data Transfer Objec의 줄임말이다. VO(Value Object)라고도 불리는데, 계층간 데이터 교환을 위한 자바 빈즈다. 데이터베이스 레코드의 데이터를 매핑하기 위한 데이터 객체를 말하는데, DTO는 보통 로직을 가지고 있지 않고 data와 그 data에 접근을 위한 getter, setter만 가지고 있다.
<br><br>

# Connection pool
**Connection pool**: 커넥션을 미리 모아두었다가, 필요 할 때마다 커넥션을 가져와 쓰고 다쓰면 풀에 반납하는 방식이다. 즉, 클라이언트가 DB와 연결해야 할 때 필요한 커넥션을 미리 담아놓은 웅덩이이다. 웹에서 DB가 연결되면 커넥션을 제공하는데, 동시 접속이 많아져 사용 할 유저가 많다면, 커넥션이 부족해 서버가 다운되기 때문에, 부족 할 때 나머지를 대기시켜 방지하기 위함이다.(서버의 안정성 보장) 또한, 클라이언트가 DB로 항상 직접 접근해서 연결을 시도하면, 시간이 오래 걸리기 때문에, 미리 연결해  놓고 가져다 쓸 수 있도록 하여 성능을 향상시킨다.

# Spring Framework
자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크로서 간단히 스프링(Spring)이라고도 불린다.
동적인 웹사이트를 개발하기 위한 여러가지 서비스를 제공하고 있다.
대한민국 공공기관의 웹 서비스 개발 시 사용을 권장하고 있는 전자 종부 표준프레임워크의 기반 기술로서 쓰이고 있다.
ORM 프레임워크와의 연결고리를 제공한다.
<br><br>

# Spring Triangle
> - POJO : Plain Old Java Object / 오래된 방식의 자바 객체를 의미하는 말인데, 스프링에서는 구현을 위해 특정한 인터페이스를 구현하거나 상속을 받을 필요가 없어 기존에 존재하는 라이브러리 등을 지원하기에 용이하고 객체가 가벼운 것이 특징이다.
> - PSA : Portable Service Abstraction / 트랜잭션 추상화, OXM 추상화 , 데이터 액세스의 Exception 변환기능 등 기술적인 복잡함은 추상화를 통해 Low Level의 기술 구현 부분과 기술을 사용하는 인터페이스로 분리한다. 즉, 인터페이스와 구현부의 분리를 말한다.
> - AOP : Aspect Oriented Programming / 공통로직을 별도의 공간에 따로 구현하고, 이를 런타임(실행시간)에 적용이 필요한 클래스 메소드에 프록시를 사용해 적용하는 기술을 말한다. 기존의 관점 지향 프로그래밍 프레임 워크인 AspectJ 또한 내부에서 사용가능하다. OOP를 좀 더 효율적으로 만들어 나가기위한 도구.
> - IoC/DI : Inversion of Control/Dependency Injection / 제어의 역전과 의존성 주입이라 번역이되는데, 이는 해당 컨테이너가 객체의 생성 및 관계설정, 의존성 주입을 통해 개발자가 직접하지 않고 프레임워크가 대신 맡아서 처리하는것을 말한다.

<img src="https://github.com/minuk8932/How-to-buildup-Server-by-Spring/blob/master/img/spring-triangle.png" width=200>

[그림 3] Spring Triangle
<br><br>

# JPA
Java Persistence API의 약자로, 자바 진영의 ORM 기술 표준이다. JPA는 application과 JDBC 사이에서 동작한다. JPA는 EJB(Enterprise Java Beans) 3.0에서 하이버네이트 기반으로 만들어진 ORM 기술에 대한 API 표준 명세다.(즉, 인터페이스들의 집합)
<br><br>

# Why JPA?
1. 생산성 : JPA를 사용하면 자바 컬렉션에 객체를 저장하듯이 JPA에게 해당 객체를 전달하면 된다. SQL 명령어나, JDBC API를 사용하는 반복적인 일은 JPA가 대신 처리해준다. <br>
```Java
// 예제 코드 : 객체를 컬렉션에 저장하듯이 JPA에게 전달하는 코드

jpa.persist(member); // 저장
Member member = jpa.find(memeberId); // 조회
```
<br>

2. 유지 보수 : JPA의 기능으로 코드가 간략해져, 유지보수에 걸리는 시간이 줄어들었다.
- 좀 더 자세히 말하면, JDBC 사용시 엔티티에 필드 하나만 추가되어도, 관련된 등록/수정/조회 SQL과 결과를 매핑하기위한 모든 코드를 변경해야 했지만, JPA를 사용하면 이러한 과정을 JPA가 대신 처리해 주기 때문에, 수정해야 할 코드길이가 줄어든다.
<br>

3. 패러다임의 불일치 해결 : JPA는 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 **_패러다임의 불일치_** 문제를 해결해준다.
- 객체 지향 언어와 그에 따라 데이터베이스에 데이터를 저장하는데 생기는 문제들로, 예를 들어 어떤 팀 객체를 참조하고있는 회원 객체를 저장하려 할 때는 해당 팀 객체도 함께 저장하지 않으면 참조하는 팀 객체를 잃는 문제가 발생한다. 즉 간단히 말하면, 객체 구조를 테이블 구조에 저장하는데 있어 발생하는 한계에 따른 문제를 **_패러다임의 불일치_** 라고한다.
<br>

4. 성능 : 객체 재사용을 통해 성능이 좋아지고, 지속적인 DB로의 접근을 막는다. <br>
```Java
// 예를 들어 이러한 코드 같은 경우, 데이터베이스와의 반복적인 통신이 필요하다.
String memberId = "memberId1";
Member member1 = jpa.find(memberId);  // JPA가 아닌경우 DB 1회 접근
Member member2 = jpa.find(memberId);  // DB 2회 접근
```
- 그러나, JPA를 어플리케이션과 데이터베이스 사이에 두면, 조회하는 SQL문을 1회만 데이터베이스로 전달하고, 그 다음부턴 조회한 회원 객체 재사용이 가능해 성능을 높힐 수 있다.
<br>

5. 데이터 접근 추상화와 벤더 독립성 : JPA는 어플리케이션과 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공하여, 특정 데이터베이스 기술에 종속되는 것을 피한다. 이 계층을 **Dialect(방언)** 이라고 하는데, 만약 데이터베이스를 변경하게 되면, 다른 데이터베이스를 사용한다고 선언해주기만 하면 된다.
<br>

6. 표준 : JPA는 표준 기술으로서, 다른 구현 기술로 손쉽게 변경이 가능하다.
<br><br>

# Persistence Context
'엔티티를 저장하고 관리'하는 것이 영속성 컨텍스트인데, 이 컨텍스트는 내부의 1차캐시를 갖고, 해당 캐시내에 영속성 상태의 엔티티를 저장해둔다.
JDBC와 DB사이에서 작동하며, 반복적인 DB로의 접근을 막고 영속성 상태의 엔티티를 반환해 주는 역할을 한다.<br>
아래와 같은 방식으로 영속성 컨텍스트가 동작하며 DB로의 접근을 줄여준다.<br>
```
1. 조회할 데이터가 영속성 컨텍스트에 존재하는지 확인
2. 데이터가 없으면 쿼리를 생성
3. 쿼리를 DB에 전송
4. 결과 값을 영속성컨텍스트가 전달 받음
5. 전달 받은 데이터를 엔티티로 저장
6. 엔티티 인스턴스를 리턴
```

해당 내용은 공부하며 지속적으로 수정해나갈 계획입니다.
